# Programming:
#
# Add a run configuration named "deploy" with the following parameters
#
# Executable:           teensy-cli
# Arguments:            --mcu=[$MMCU] -w -v %{CurrentProject:FileBaseName}.hex
# Working Directory:    %{buildDir}
#

# Build the various output files used by the programmer
#QMAKE_POST_LINK = make coff extcoff hex lss sym
QMAKE_POST_LINK = make hex

# MCU name, you MUST set this to match the board you are using
# type "make clean" after changing this, so all files will be rebuilt
#
#MMCU=at90usb162    # Teensy 1.0
MMCU=atmega32u4     # Teensy 2.0
#MMCU=at90usb646    # Teensy++ 1.0
#MMCU=at90usb1286   # Teensy++ 2.0

QMAKE_AR        = avr-ar cqs
QMAKE_OBJCOPY   = avr-objcopy
QMAKE_NM        = avr-nm -P
QMAKE_COMPILER  = avr-gcc
QMAKE_CC        = avr-gcc
QMAKE_CXX       = avr-g++
QMAKE_LINK      = avr-gcc

#QMAKE_CFLAGS_APP -= -fPIE
INCLUDEPATH += /usr/lib/avr/include

# Debugging format.
#   Native formats for AVR-GCC's -g are dwarf-2 [default] or stabs.
#   AVR Studio 4.10 requires dwarf-2.
#   AVR [Extended] COFF format requires stabs, plus an avr-objcopy run.
DEBUG=dwarf-2

# Processor frequency.
#   Normally the first thing your program should do is set the clock prescaler,
#   so your program will run at the correct speed.  You should also set this
#   variable to same clock speed.  The _delay_ms() macro uses this, and many
#   examples use this variable to calculate timings.  Do not add a "UL" here.
F_CPU = 16000000

# Output format. (can be srec, ihex, binary)
FORMAT = ihex

# Optimization level, can be [0, 1, 2, 3, s].
#   0 = turn off optimization. s = optimize for size.
#   (Note: 3 is not always the best optimization level. See avr-libc FAQ.)
OPTIMIZE=s

# \todo: Add lst files in the build directory generated by the compiler
#QMAKE_CLEAN += ${QMAKE_FILE_NAME}.lst

#---------------- Compiler Options C ----------------
#  -g*:          generate debugging information
#  -O*:          optimization level
#  -f...:        tuning, see GCC manual and avr-libc documentation
#  -Wall...:     warning level
#  -Wa,...:      tell GCC to pass this to the assembler.
#  -adhlns...: create assembler listing
QMAKE_CFLAGS += -mmcu=$${MMCU}
QMAKE_CFLAGS += -DF_CPU=$${F_CPU}UL
QMAKE_CFLAGS += -g$${DEBUG}
QMAKE_CFLAGS += -O$${OPTIMIZE}
QMAKE_CFLAGS += -funsigned-char
QMAKE_CFLAGS += -funsigned-bitfields
QMAKE_CFLAGS += -ffunction-sections
QMAKE_CFLAGS += -fpack-struct
QMAKE_CFLAGS += -fshort-enums
QMAKE_CFLAGS += -Wstrict-prototypes
QMAKE_CFLAGS += -Wa,-adhlns=$(*F).lst
QMAKE_CFLAGS += -std=gnu99

#---------------- Compiler Options C++ ----------------
#  -g*:          generate debugging information
#  -O*:          optimization level
#  -f...:        tuning, see GCC manual and avr-libc documentation
#  -Wall...:     warning level
#  -Wa,...:      tell GCC to pass this to the assembler.
#  -adhlns...: create assembler listing
QMAKE_CXXFLAGS += -mmcu=$${MMCU}
QMAKE_CXXFLAGS += -DF_CPU=$${F_CPU}UL
QMAKE_CXXFLAGS += -g$${DEBUG}
QMAKE_CXXFLAGS += -O$${OPTIMIZE}
QMAKE_CXXFLAGS += -funsigned-char
QMAKE_CXXFLAGS += -funsigned-bitfields
QMAKE_CXXFLAGS += -fpack-struct
QMAKE_CXXFLAGS += -fshort-enums
QMAKE_CXXFLAGS += -fno-exceptions
QMAKE_CXXFLAGS += -Wundef
QMAKE_CXXFLAGS += -Wa,-adhlns=$(*F).lst

## Linker flags
QMAKE_LFLAGS += -mmcu=$${MMCU}
QMAKE_LFLAGS += -DF_CPU=$${F_CPU}UL
QMAKE_LFLAGS += -O$${OPTIMIZE}

# todo: Build the hex file with QMAKE_EXTRA_COMPILERS or QMAKE_EXTRA_TARGETS
#QMAKE_POST_LINK = avr-objcopy -O $${FORMAT} -R .eeprom -R .fuse -R .lock -R .signature $$TARGET ${TARGET}.hex

# Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
COFFCONVERT = $$QMAKE_OBJCOPY --debugging
COFFCONVERT += --change-section-address .data-0x800000
COFFCONVERT += --change-section-address .bss-0x800000
COFFCONVERT += --change-section-address .noinit-0x800000
COFFCONVERT += --change-section-address .eeprom-0x810000


# Add the coff output to the extra targets
COFF.target = coff
COFF.commands = $$COFFCONVERT -O coff-avr $$TARGET ${TARGET}.cof
COFF.depends = ${TARGET}
QMAKE_EXTRA_TARGETS += COFF
QMAKE_CLEAN += ${TARGET}.cof

# Add the extended coff output to the extra targets
EXTCOFF.target = extcoff
EXTCOFF.commands = $$COFFCONVERT -O coff-ext-avr $$TARGET ${TARGET}.ext.cof
EXTCOFF.depends = ${TARGET}
QMAKE_EXTRA_TARGETS += EXTCOFF
QMAKE_CLEAN += ${TARGET}.ext.cof

# Add the hex output to the extra targets
HEX.target = hex
HEX.commands = $$QMAKE_OBJCOPY -O $${FORMAT} -R .eeprom -R .fuse -R .lock -R \
    .signature $$TARGET ${TARGET}.hex
HEX.depends = ${TARGET}
QMAKE_EXTRA_TARGETS += HEX
QMAKE_CLEAN += ${TARGET}.hex

# Create extended listing file from ELF output file.
LSS.target = lss
LSS.commands = avr-objdump -h -S -z $$TARGET > ${TARGET}.lss
LSS.depends = ${TARGET}
QMAKE_EXTRA_TARGETS += LSS
QMAKE_CLEAN += ${TARGET}.lss

# Create a symbol table from ELF output file.
SYM.target = sym
SYM.commands = $$QMAKE_NM -n $$TARGET > ${TARGET}.sym
SYM.depends = ${TARGET}
QMAKE_EXTRA_TARGETS += SYM
QMAKE_CLEAN += ${TARGET}.sym
